//------------------------------------------------------------------------------
// Copyright (c) 2011 by Silicon Laboratories Inc.  All rights reserved.
// The program contained in this listing is proprietary to Silicon Laboratories,
// headquartered in Austin, Texas, U.S.A. and is subject to worldwide copyright
// protection, including protection under the United States Copyright Act of 1976
// as an unpublished work, pursuant to Section 104 and Section 408 of Title XVII
// of the United States code.  Unauthorized copying, adaptation, distribution,
// use, or display is prohibited by this law.
//
// Silicon Laboratories provides this software solely and exclusively
// for use on Silicon Laboratories' microcontroller products.
//
// This software is provided "as is".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
// SILICON LABORATORIES SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL,
// INCIDENTAL, OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
//------------------------------------------------------------------------------

//==============================================================================
// WARNING:
//
// This file is auto-generated by AppBuilder and should not be modified.
// Any hand modifications will be lost if the project is regenerated.
//==============================================================================
// library
#include <stdio.h>
// hal
#include <si32_device.h>
#include <SI32_CLKCTRL_A_Type.h>
#include <SI32_UART_A_Type.h>
#include <SI32_PBSTD_A_Type.h>
#include <SI32_PBCFG_A_Type.h>
// application
#include "config.h"
#include "uart.h"
extern volatile uint32_t msTicks;
#define UART_TIME_OUT 1000 // 1 second time out
//==============================================================================
//SUPPORT FUNCTIONS
//==============================================================================
#if 0
//------------------------------------------------------------------------------
// UART0_send_char()
//
// Outputs a single character to UART0.  This function is called by 
// a modified version of fputc() defined in "retarget_arm.c". 
//------------------------------------------------------------------------------
void UART0_send_char(uint8_t val)
{
  // Block if the output buffer is full
  while (SI32_UART_A_read_tx_fifo_count(SI32_UART_0) >= 4);

  // Write character to the output buffer
  SI32_UART_A_write_data_u8(SI32_UART_0, val);
}

//------------------------------------------------------------------------------
// UART0_get_char()
//
// Returns a single character received from UART0.  This function is called by 
// a modified version of fgetc() defined in "retarget_arm.c". 
//
// Note: This is a blocking function.
//------------------------------------------------------------------------------
int8_t UART0_get_char(uint8_t *c)
{
  // Block if input buffer is empty
  if (SI32_UART_A_read_rx_fifo_count(SI32_UART_0) != 0)
  {
  // Read character from the input buffer
     *c = SI32_UART_A_read_data_u8(SI32_UART_0);
     return 0;
  }
  return -1;
}
#endif

void uart_send_data(unsigned char *data, unsigned int count)
{
   while(count--)
   {
      // Block if the output buffer is full
      while (SI32_UART_A_read_tx_fifo_count(SI32_UART_0) >= 4);
      // Write character to the output buffer
      SI32_UART_A_write_data_u8(SI32_UART_0, *data++);
   }
}

int uart_get_data(unsigned char *data, unsigned int count)
{
   unsigned int time_out;
   while(count--)
   {
      time_out = msTicks + UART_TIME_OUT;
      while(SI32_UART_A_read_rx_fifo_count(SI32_UART_0) == 0)
      {
         if(time_out < msTicks)
         {
            return -1;
         }
      }
      *data++ = SI32_UART_A_read_data_u8(SI32_UART_0);
   }
   return 0;
}
#if 0
void print_hex(unsigned int code)
{
   int i;
   unsigned int tmp;
   UART0_send_char('0');
   UART0_send_char('x');
   for(i = 0; i < 8; i++)
   {
      tmp = (code & 0xF0000000) >> 28;
      code <<= 4;
      if (tmp <= 9)
      {
         tmp +=0x30;
      }
      else
      {
         tmp += (0x41 - 10);
      }
      UART0_send_char(tmp);
   }
   UART0_send_char(0x0a); // LF
   UART0_send_char(0x0d); // CR
}
#endif
//------------------------------------------------------------------------------
void UART0_initialize(void)
{
   SI32_PBCFG_A_enable_crossbar_0(SI32_PBCFG_0);
   // UART PINS TO PROPER CONFIG (TX = PB1.12, RX = PB1.13)
   SI32_PBSTD_A_set_pins_push_pull_output(SI32_PBSTD_1, 0x0001000);
   SI32_PBSTD_A_set_pins_digital_input(SI32_PBSTD_1, 0x00002000);
   SI32_PBSTD_A_write_pbskipen(SI32_PBSTD_0, 0x0000FFFF);
   SI32_PBSTD_A_write_pbskipen(SI32_PBSTD_1, 0x00000FFF);
   // BRING OUT UART
   SI32_PBCFG_A_enable_xbar0h_peripherals(SI32_PBCFG_0, SI32_PBCFG_A_XBAR0H_UART0EN);

   // ENABLE UART0 CLOCK
   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0,
                                                   SI32_CLKCTRL_A_APBCLKG0_UART0);

   // SETUP UART. BAUD RATE (9600 baud, APB = System Clock)
   SI32_UART_A_enter_full_duplex_mode(SI32_UART_0);
   SI32_UART_A_set_tx_baudrate(SI32_UART_0, (SystemCoreClock / (2 * UART_BAUD_RATE)) - 1);
   SI32_UART_A_set_rx_baudrate(SI32_UART_0, (SystemCoreClock / (2 * UART_BAUD_RATE)) - 1);

   // SETUP TX (8-bit, 1stop, no-parity)
   SI32_UART_A_select_tx_data_length(SI32_UART_0, 8);
   SI32_UART_A_enable_tx_start_bit(SI32_UART_0);
   SI32_UART_A_enable_tx_stop_bit(SI32_UART_0);
   SI32_UART_A_disable_tx_parity_bit(SI32_UART_0);
   SI32_UART_A_select_tx_stop_bits(SI32_UART_0, SI32_UART_A_STOP_BITS_1_BIT);
   SI32_UART_A_disable_tx_signal_inversion(SI32_UART_0);
   SI32_UART_A_enable_tx(SI32_UART_0);

   // SETUP RX
   SI32_UART_A_select_rx_data_length(SI32_UART_0, 8);
   SI32_UART_A_enable_rx_start_bit(SI32_UART_0);
   SI32_UART_A_enable_rx_stop_bit(SI32_UART_0);
   SI32_UART_A_select_rx_stop_bits(SI32_UART_0, SI32_UART_A_STOP_BITS_1_BIT);
   SI32_UART_A_disable_rx_signal_inversion(SI32_UART_0);
   SI32_UART_A_select_rx_fifo_threshold_1(SI32_UART_0);
   SI32_UART_A_enable_rx(SI32_UART_0);
}

//-eof--------------------------------------------------------------------------
