{"name":"Sim3u1xx bootloader","tagline":"Bootloader for ARM Cortex M3 UART interface","body":"Make own bootloader for ARM Cortex M3\r\n=====================================\r\n\r\n## 1 Bootloader overview\r\nA Bootloader is a small application that is used to load new user applications to devices. After it is loaded, the new user application is able to run in the MCU. It works with two modes, user application and Bootloader mode. \r\n\r\nWe are discussing common way to implement Bootloader on your own Arm Cortez  M3. And we choose Silicon labs SIM3U167 MCU as example for making Bootloader. \r\n\r\n## 2 Bootloader design method\r\n### 2.1  Bootloader need to run in SRAM\r\n### 2.1.1 Bootloader behavior\r\nBootloader is an application which runs from internal flash, in case of update Bootloader itself requirement, the Bootloader code needed to be copied into internal SRAM and run.\r\n* The Bootloader code address need to set in SRAM in link file\r\n* The vector table entry needs to update from flash to SRAM after copying Bootloader into SRAM.\r\n* The Reset vector address we want to keep its original address, since it is hardware behavior.\r\n\r\n### 2.1.2 Arm Cortex M3 internal memory map\r\n* Internal flash address (0x00000000-0x1FFFFFFF).\r\n* Internal SRAM address (0x20000000-0x3FFFFFFF).\r\n* Peripherals address (0x40000000-0x5FFFFFFF).\r\n* System levels address (0xE0000000-0xFFFFFFFF).\r\n\r\nSo base on above memory, we need to copy code from internal flash address to internal SRAM address. And access UART peripheral register in Peripherals address, and change vector table address need to access register in System levels address.\r\n\r\n### 2.1.3 Link file \r\nTo make sure Bootloader code is located in SRAM, we need to specific the address setting in link file.  Now we have a Bootloader_link.ld as our link file. We would talk detail about how to write link file, we assume that you \r\nalready know the basic knowledge about link file.\r\n```ld\r\n.text 0x20000000 : AT (0x00000000)\r\n{\r\n    . = ALIGN(4);\r\n    _text = .;\r\n    KEEP(*(.isr_vector))\r\n    *(.text*)\r\n    *(.rodata*)\r\n    _etext = .;\r\n}\r\n```\r\n\r\nThe first line `.text 0x20000000 : AT (0x00000000)` means .text section load address start from 0x20000000, store address from 0x00000000.  \r\n\r\nInside the description, we put `.isr_vector`, `*(.text*)` and `*(.rodata*)` in .text section. The `.isr_vector` is vector entry; we put it in front of Bootloader code.\r\n\r\nAnd then we have other two sections .data and .bss\r\n```ld\r\n.data 0x20000000 + SIZEOF(.text) : AT (LOADADDR(.text) + SIZEOF(.text))\r\n{\r\n    _data = .;\r\n    *(.data*)\r\n    _edata = .;\r\n}\r\n\r\n.bss 0x20000000 + SIZEOF(.text) + SIZEOF(.data) :\r\n    AT (LOADADDR(.data) + SIZEOF(.data))\r\n{\r\n    _bss = .;\r\n    *(.bss*)\r\n    *(COMMON)\r\n    _ebss = .;\r\n}\r\n```\r\nAnd now the link file is ready.\r\n\r\n### 2.1.4 Vector table introduction. \r\nBy default Arm Cortex M3 vector table starts at memory address 0. The vector table can be relocated to other memory locations in the code or Random Access Memroy(RAM) region where the RAM is so that we can change the handlers during run time. This is down by settting a register in the NVIC called the vector table offset register (address `0xE000ED08`). You need to have the following (at a minimum).\r\n* Initial main stack pointer value\r\n* Reset vector\r\n* NMI vector\r\n* Hard fault vector\r\n\r\n### 2.1.5 Vector table in startup file\r\nWe prepare startup_sim3u1xx.S for our startup file. In this file, we will have the vector table, code copy from flash to SRAM, jump to user application code. Let us have a look on vector table first. We can see .isr_vector in link file is the vector table section name.\r\n\r\n```asm\r\n    .section .isr_vector\r\nVectors:\r\n    .word   0x20008000                  // The initial stack pointer\r\n    .word   ResetISR - 0x20000000       // The reset handler\r\n    .word   NMI_Handler                 // The NMI handler\r\n    .word   HardFault_Handler           // The hard fault handler\r\n    .word   Default_Handler             // The MPU fault handler\r\n    .word   Default_Handler             // The bus fault handler\r\n    .word   Default_Handler             // The usage fault handler\r\n    .word   0                           // Reserved\r\n    .word   0                           // Reserved\r\n    .word   0                           // Reserved\r\n    .word   0                           // Reserved\r\n    .word   Default_Handler             // SVCall handler\r\n    .word   Default_Handler             // Debug monitor handler\r\n    .word   0                           // Reserved\r\n    .word   Default_Handler             // The PendSV handler\r\n    .extern SysTick_Handler\r\n    .word   SysTick_Handler             // The SysTick handler\r\n```\r\n\r\nNote:\r\n* Stack pointer we set is 0x20008000, that is because SIM3U167 internal SRAM size is 32KB (0x20000000-0x20007FFF). \r\n* Reset handler address we minus 0x20000000, that is because, Arm will check the value in second word and jump to address in it. Since all Bootloader code was locate at SRAM (0x20000000), but at the time power up, all the codes are in internal flash, and didn’t copy to SRAM yet. So we have to set ResetISR address point to flash in order Arm can execute code correctly.\r\n* Other exception handlers. We need to keep some import exception handlers; we will see HardFault_Handler happens many times during the Bootloader development in case the address not matches.\r\n\r\n### 2.1.6 ResetISR implements.\r\nWe need to handle code that Arm will first execute, ResetISR.  What does this function do?\r\n* Copy code to SRAM and initialize variables.\r\n* Initialize system hardware\r\n* Check external pin status to run under Bootloader or user application mode.\r\n\r\nHere is the cod structure of ResetISR\r\n\r\n```asm\r\n    .globl  ResetISR\r\n    .thumb_func\r\nResetISR:\r\n    // Copy code from flash to SRAM\r\n    bl      CopyCode2SRAM\r\n    .extern SystemInit\r\n    bl SystemInit\r\n    // Check if update is needed\r\n    .extern check_update_requirement\r\n    bl      check_update_requirement\r\n    cbz     r0, RunUserCode\r\n\r\n    .extern main\r\n    bl main\r\n```\r\n\r\n### 2.1.6.1 Copy code to SRAM and initialize variables.\r\nLet us take a look on CopyCode2SRAM function.\r\n```asm\r\n    .text\r\n    .thumb_func\r\nCopyCode2SRAM:\r\n    // Copy the text and data sections from flash to SRAM.\r\n    movs    r0, #0x00000000\r\n    ldr     r1, =0x20000000\r\n    .extern _bss\r\n    ldr     r2, =_bss\r\ncopy_loop:\r\n    ldr     r3, [r0], #4\r\n    str     r3, [r1], #4\r\n    cmp     r1, r2\r\n    blt     copy_loop\r\n\r\n    // Zero fill the bss segment\r\n    movs    r0, #0x00000000\r\n    .extern _ebss\r\n    ldr     r2, =_ebss\r\nzero_loop:\r\n    str     r0, [r1], #4\r\n    cmp     r1, r2\r\n    blt     zero_loop\r\n\r\n    // Set the vector table pointer to SRAM.\r\n    ldr     r0, =0xe000ed08\r\n    ldr     r1, =0x20000000\r\n    str     r1, [r0]\r\n    // set return address to SRAM and return\r\n    orr     lr, lr, #0x20000000\r\n    bx      lr\r\n```\r\n\r\n The code is very simple.\r\n\r\n* Copy `.text` and `.data` from flash to SRAM\r\n* Zero `.bss` segment in SRAM\r\n* Relocate vector table address and return to SRAM to execute.\r\n\r\nNote:\r\n* `_bss` is defined in link file, which is address after .text and .data. So the copy_loop is copy code from flash to SRAM until it reaches _bss address. \r\n* `_ess` is defined in linke file, which is address after .bss segment. So zero_lopp, just write “0” into SRAM follow the .text and .data segment, until it reaches _ebss address.\r\n* And finally, we write new vector table address (0x20000000) into register `0xe00ed08`, and set return address to SRAM and return.\r\n\r\n### 2.1.6.2 Initialize system hardware\r\nThe idea is very simple too, set necessary hardware environment we need in startup file. For instance, we need to check GPIO status to choose running mode. We have to enable clock to GPIO and set the GPIO as input mode and something like that. I paste the example of SystemInit.\r\n\r\n```c\r\nvoid mySystemInit(void)\r\n{\r\n   SI32_WDTIMER_A_stop_counter (SI32_WDTIMER_0);\r\n   // Enable the APB clock to the PB registers\r\n   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0, SI32_CLKCTRL_A_APBCLKG0_PB0);\r\n   SI32_PBSTD_A_set_pins_push_pull_output(SI32_PBSTD_1, 0x00000008);\r\n\r\n   SI32_PBCFG_A_enable_crossbar_1(SI32_PBCFG_0);\r\n   SI32_PBSTD_A_set_pins_digital_input(SI32_PBSTD_2,0x00000300);\r\n   // Enable the LED drivers (P2.10, P2.11)\r\n   SI32_PBSTD_A_set_pins_push_pull_output(SI32_PBSTD_2, 0x00000C00);\r\n   SysTick_Config(SystemCoreClock / 1000);\r\n   // set Priority for Cortex-M0 System Interrupts.\r\n   NVIC_SetPriority(SysTick_IRQn, (1 << __NVIC_PRIO_BITS) - 1);\r\n}\r\n```\r\n\r\n### 2.1.6.3 Check external pin status to run Bootloader or user application \r\nThe code call check_update_requirement to check GPIO status, if the GPIO is high, we enter into user application mode; if the GPIO is low, we enter into Bootloader mode. Let’s check user application mode entry code.\r\n\r\n```asm\r\n    .thumb_func\r\nRunUserCode:\r\n    // Set the vector table address to user code address.\r\n    ldr     r0, =USER_CODE_ADDRESS\r\n    ldr     r1, =0xe000ed08\r\n    str     r0, [r1]\r\n\r\n    // Update stack pointer from user code vector table\r\n    ldr     r1, [r0]\r\n    mov     sp, r1\r\n\r\n    // Load user code reset handler and jump to the user code\r\n    ldr     r0, [r0, #4]\r\n    bx      r0\r\n```\r\n\r\nYeah, we have to relocate vector table if we want run user application. Note we have a macro `USER_CODE_ADDRESS` which is user application start address. At the end we load user code reset handler and jump to the user code.\r\n\r\nOK, we will talk about Bootloader mode in next couple sections.\r\n\r\n### 2.2 Bootloader communicate with PC host tool via UART.\r\nWe choose UART interface as communication port with PC host since it is easier to implement. Just have a look on SIM3U167 reference manual, initialize UART peripherals, and set it as 115200 baud rate. Prepare UART send and received functions.  \r\n* UART hardware peripherals initialization. Those codes can be generated by Silabs AppBuilder.\r\n\r\n```c\r\nVoid UART0_initialize(void)\r\n{\r\n   SI32_PBCFG_A_enable_crossbar_0(SI32_PBCFG_0);\r\n   // UART PINS TO PROPER CONFIG (TX = PB1.12, RX = PB1.13)\r\n   SI32_PBSTD_A_set_pins_push_pull_output(SI32_PBSTD_1, 0x0001000);\r\n   SI32_PBSTD_A_set_pins_digital_input(SI32_PBSTD_1, 0x00002000);\r\n   SI32_PBSTD_A_write_pbskipen(SI32_PBSTD_0, 0x0000FFFF);\r\n   SI32_PBSTD_A_write_pbskipen(SI32_PBSTD_1, 0x00000FFF);\r\n   // BRING OUT UART\r\n   SI32_PBCFG_A_enable_xbar0h_peripherals(SI32_PBCFG_0, SI32_PBCFG_A_XBAR0H_UART0EN);\r\n\r\n   // ENABLE UART0 CLOCK\r\n   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0,\r\n                                          SI32_CLKCTRL_A_APBCLKG0_UART0);\r\n\r\n   // SETUP UART. BAUD RATE (9600 baud, APB = System Clock)\r\n   SI32_UART_A_enter_full_duplex_mode(SI32_UART_0);\r\n   SI32_UART_A_set_tx_baudrate(SI32_UART_0, (SystemCoreClock / (2 * UART_BAUD_RATE)) – 1);\r\n   SI32_UART_A_set_rx_baudrate(SI32_UART_0, (SystemCoreClock / (2 * UART_BAUD_RATE)) – 1);\r\n   // SETUP TX (8-bit, 1stop, no-parity)\r\n   SI32_UART_A_select_tx_data_length(SI32_UART_0, 8);\r\n   SI32_UART_A_enable_tx_start_bit(SI32_UART_0);\r\n   SI32_UART_A_enable_tx_stop_bit(SI32_UART_0);\r\n   SI32_UART_A_disable_tx_parity_bit(SI32_UART_0);\r\n   SI32_UART_A_select_tx_stop_bits(SI32_UART_0, SI32_UART_A_STOP_BITS_1_BIT);\r\n   SI32_UART_A_disable_tx_signal_inversion(SI32_UART_0);\r\n   SI32_UART_A_enable_tx(SI32_UART_0);\r\n   // SETUP RX\r\n   SI32_UART_A_select_rx_data_length(SI32_UART_0, 8);\r\n   SI32_UART_A_enable_rx_start_bit(SI32_UART_0);\r\n   SI32_UART_A_enable_rx_stop_bit(SI32_UART_0);\r\n   SI32_UART_A_select_rx_stop_bits(SI32_UART_0, SI32_UART_A_STOP_BITS_1_BIT);\r\n   SI32_UART_A_disable_rx_signal_inversion(SI32_UART_0);\r\n   SI32_UART_A_select_rx_fifo_threshold_1(SI32_UART_0);\r\n   SI32_UART_A_enable_rx(SI32_UART_0);\r\n}\r\n```\r\n\r\n* UART send and receive functions.\r\n\r\n```c\r\nVoid uart_send_data(unsigned char *data, unsigned int count)\r\n{\r\n   while(count--)\r\n   {\r\n      // Block if the output buffer is full\r\n      while (SI32_UART_A_read_tx_fifo_count(SI32_UART_0) >= 4);\r\n      // Write character to the output buffer\r\n      SI32_UART_A_write_data_u8(SI32_UART_0, *data++);\r\n   }\r\n}\r\n\r\nint uart_get_data(unsigned char *data, unsigned int count)\r\n{\r\n   unsigned int time_out;\r\n   while(count--)\r\n   {\r\n      time_out = msTicks + UART_TIME_OUT;\r\n      while(SI32_UART_A_read_rx_fifo_count(SI32_UART_0) == 0)\r\n      {\r\n         if(time_out < msTicks)\r\n         {\r\n            return -1;\r\n         }\r\n      }\r\n      *data++ = SI32_UART_A_read_data_u8(SI32_UART_0);\r\n   }\r\n   return 0;\r\n}\r\n```\r\n\r\n### 2.3 Bootloader receive firmware from PC and burn it into flash.\r\nThe UART driver was ready. We need to write user application into flash and flash device driver is needed now.\r\n* Flash hardware peripherals initialization.\r\n\r\n```c\r\nVoid flash_initialize(void)\r\n{\r\n   // ENABLE FLASH CLOCK\r\n   SI32_CLKCTRL_A_enable_apb_to_modules_0(SI32_CLKCTRL_0,\r\n                                          SI32_CLKCTRL_A_APBCLKG0_FLCTRLCEN_ENABLED_U32);\r\n   // 1. Enable VDD Supply Monitor and set as a reset source\r\n   SI32_VMON_A_enable_vdd_supply_monitor(SI32_VMON_0);\r\n   SI32_RSTSRC_A_enable_vdd_monitor_reset_source(SI32_RSTSRC_0);\r\n}\r\n```\r\n\r\n* Flash operation functions\r\n\r\n```c\r\nvoid flash_erase_page(unsigned int addr)\r\n{\r\n   SI32_FLASHCTRL_A_exit_multi_byte_write_mode(SI32_FLASHCTRL_0);\r\n   SI32_FLASHCTRL_A_write_wraddr(SI32_FLASHCTRL_0, addr);\r\n   SI32_FLASHCTRL_A_enter_flash_erase_mode(SI32_FLASHCTRL_0);\r\n   SI32_FLASHCTRL_A_write_flash_key(SI32_FLASHCTRL_0, 0xA5);\r\n   SI32_FLASHCTRL_A_write_flash_key(SI32_FLASHCTRL_0, 0xF1);\r\n   SI32_FLASHCTRL_A_write_wrdata(SI32_FLASHCTRL_0, 0x0000);\r\n   while(SI32_FLASHCTRL_A_is_buffer_full(SI32_FLASHCTRL_0));\r\n}\r\n\r\nint flash_write_data(unsigned char * c,unsigned int addr, unsigned int num)\r\n{\r\n   int i;\r\n   unsigned short *buf = (unsigned short*)c;\r\n   SI32_FLASHCTRL_A_exit_flash_erase_mode(SI32_FLASHCTRL_0);\r\n   SI32_FLASHCTRL_A_write_wraddr(SI32_FLASHCTRL_0, addr);\r\n   SI32_FLASHCTRL_A_enter_multi_byte_write_mode(SI32_FLASHCTRL_0);\r\n   SI32_FLASHCTRL_A_write_flash_key(SI32_FLASHCTRL_0, 0xA5);\r\n   SI32_FLASHCTRL_A_write_flash_key(SI32_FLASHCTRL_0, 0xF2);\r\n   // Write all the half-words in the array\r\n   for(i = 0; i < num / 2; i++)\r\n   {\r\n      SI32_FLASHCTRL_A_write_wrdata(SI32_FLASHCTRL_0, buf[i]);\r\n      while(SI32_FLASHCTRL_A_is_flash_busy(SI32_FLASHCTRL_0));\r\n   }\r\n   while(SI32_FLASHCTRL_A_is_buffer_full(SI32_FLASHCTRL_0));\r\n   SI32_FLASHCTRL_A_write_flash_key(SI32_FLASHCTRL_0, 0x5A);\r\n   return 0;\r\n}\r\n```\r\n\r\n## 3 Bootloader UART communication protocol\r\n### 3.1 Protocol definition\r\nWe can define our own protocol as we like. Also choose exist one is suitable. We list a protocol below just for reference. From view of host side.\r\n* Command package\r\n```\r\n| CMD |\r\n| CMD ^ 0xFF |\r\n| Wait for ACK |\r\n```\r\n\r\n* Address package\r\n```\r\n| ADDR3 |\r\n| ADDR2 |\r\n| ADDR1 |\r\n| ADDR0 |\r\n| CRC(=ADDR3^ADDR2^ADDR1^ADDR0) |\r\n```\r\n\r\n* Write flash command\r\n```\r\n| CMD(0x31) |\r\n| ADDR(address) |\r\n| Wait for ACK |\r\n| (LEN-1) & 0XFF |\r\n| DATA0 |\r\n| … |\r\n| DATA(LEN-1) |\r\n| CRC(=DATA0^DATA1…^DATA(LEN-1)) |\r\n| Wait for ACK |\r\n```\r\n\r\n* Read flash command\r\n```\r\n| CMD(0x11) |\r\n| ADDR(address) |\r\n| Wait for ACK |\r\n| (LEN-1) & 0XFF |\r\n| CRC (((LEN-1) & 0XFF) ^ 0xFF) |\r\n| Wait for ACK |\r\n| DATA0 |\r\n| … |\r\n| DATA(LEN-1) |\r\n```\r\n\r\n* Erase flash command\r\n```\r\n| CMD(0x43) |\r\n| LEN-1 |\r\n| SEC0 |\r\n| … |\r\n| SEC(LEN-1) |\r\n| CRC(SEC0^SEC1…^SEC(LEN-1)) |\r\n| Wait for ACK |\r\n```\r\n\r\nThe device side control logic was list below.\r\n\r\n```c\r\nWhile (1)\r\n{\r\n   SI32_PBSTD_A_toggle_pins(SI32_PBSTD_2, 0xC00);\r\n   // received CMD from host\r\n   if (bl_get_cmd() == 0)\r\n   {\r\n      switch (data_buf[0])\r\n      {\r\n         case CMD_WRITE_FLASH:\r\n            bl_write_flash();\r\n            break;\r\n         case CMD_READ_FLASH:\r\n            bl_read_flash();\r\n            break;\r\n         case CMD_ERASE_FLASH:\r\n            bl_erase_flash();\r\n            break;\r\n         default:\r\n            break;\r\n      }\r\n   }\r\n}\r\n```\r\n\r\n### 3.2 The protocol functions list below:\r\n\r\n```c\r\n#define FLASH_SECTOR_SIZE 0x400\r\n\r\n#define CMD_WRITE_FLASH     0x31\r\n#define CMD_READ_FLASH     0x11\r\n#define CMD_ERASE_FLASH     0x43\r\n#define CMD_UNKNOW         0xFF\r\n\r\n#define RES_ACK            0x79\r\n#define RES_NACK           0x1F\r\n#define RES_UNKNOW         0xEE\r\nvoid bl_send_ack(unsigned char ack)\r\n{\r\n   unsigned char res = ack;\r\n   uart_send_data(&res, 1);\r\n}\r\n```\r\n\r\n* Get command from host\r\n```c\r\nint bl_get_cmd(void)\r\n{\r\n   unsigned char *ptr = data_buf;\r\n   if (uart_get_data(ptr, 2) == 0)\r\n   {\r\n      if (ptr[0] != (ptr[1] ^ 0xFF))\r\n      {\r\n         bl_send_ack(RES_NACK);\r\n         return -2;\r\n      }\r\n      else\r\n      {\r\n         bl_send_ack(RES_ACK);\r\n         return 0;\r\n      }\r\n   }\r\n   return -1;\r\n}\r\n```\r\n\r\n* Handle write flash command\r\n```c\r\nvoid bl_write_flash()\r\n{\r\n   int i;\r\n   unsigned int addr, len;\r\n   unsigned char crc;\r\n   unsigned char *ptr = data_buf;\r\n   // get address\r\n   if (uart_get_data(ptr, 5) == 0)\r\n   {\r\n      crc = ptr[0] ^ ptr[1] ^ ptr[2] ^ ptr[3];\r\n      if (crc == ptr[4])\r\n      {\r\n         addr = ptr[3] | (ptr[2] << 8) | (ptr[1] << 16) | (ptr[0] << 24);\r\n      }\r\n   }\r\n   // send ack\r\n   bl_send_ack(RES_ACK);\r\n   // get data len\r\n   uart_get_data(ptr, 1);\r\n   len = ptr[0] + 1;\r\n   // get data and crc\r\n   if (uart_get_data(ptr, len + 1) == 0)\r\n   {\r\n      crc = 0xFF;\r\n      for (i = 0; i < len; i++)\r\n      {\r\n         crc = crc ^ ptr[i];\r\n      }\r\n   }\r\n   //write flash\r\n   if (crc == ptr[len])\r\n   {\r\n      if ((addr >= USER_CODE_ADDRESS) && addr < TOP_CODE_ADDRESS)\r\n      {\r\n         flash_write_data(ptr, addr, len);\r\n      }\r\n   }\r\n   // send ack\r\n   bl_send_ack(RES_ACK);\r\n}\r\n```\r\n\r\n* Handle read flash command\r\n```c\r\nvoid bl_read_flash()\r\n{\r\n   int i;\r\n   unsigned int addr, len = 0;\r\n   unsigned char crc;\r\n   unsigned char *ptr = data_buf;\r\n   // get address\r\n   if (uart_get_data(ptr, 5) == 0)\r\n   {\r\n      crc = ptr[0] ^ ptr[1] ^ ptr[2] ^ ptr[3];\r\n      if (crc == ptr[4])\r\n      {\r\n         addr = ptr[3] | (ptr[2] << 8) | (ptr[1] << 16) | (ptr[0] << 24);\r\n      }\r\n   }\r\n   // send ack\r\n   bl_send_ack(RES_ACK);\r\n   // get data len and crc\r\n   if(uart_get_data(ptr, 2) == 0)\r\n   {\r\n      if((ptr[0] ^ 0xFF) == ptr[1])\r\n      {\r\n         len = ptr[0] + 1;\r\n      }\r\n   }\r\n   // send ack\r\n   bl_send_ack(RES_ACK);\r\n   // send data\r\n   for(i =0; i < len; i++)\r\n   {\r\n      ptr[i]= *(unsigned char *)(addr++);\r\n   }\r\n   uart_send_data(ptr,len);\r\n}\r\n```\r\n\r\n* Handle erase flash command\r\n```c\r\nvoid bl_erase_flash()\r\n{\r\n   int i;\r\n   unsigned int addr, len;\r\n   unsigned char crc;\r\n   unsigned char *ptr = data_buf;\r\n\r\n   // get len\r\n   if (uart_get_data(ptr, 1) == 0)\r\n   {\r\n      len = (ptr[0] + 1) & 0xFF; // maximum sector number is 256\r\n   }\r\n   // get sector sequence and crc\r\n   if (uart_get_data(ptr, len + 1) == 0)\r\n   {\r\n      crc = 0xFF;\r\n      for (i = 0; i < len; i++)\r\n      {\r\n         crc = crc ^ ptr[i];\r\n      }\r\n   }\r\n   // erase flash sectors\r\n   if (crc == ptr[len])\r\n   {\r\n      for (i = 0; i < len; i++)\r\n      {\r\n         addr = ptr[i] * FLASH_SECTOR_SIZE;\r\n         if ((addr >= USER_CODE_ADDRESS) && addr < TOP_CODE_ADDRESS)\r\n         {\r\n            flash_erase_page(addr);\r\n         }\r\n      }\r\n   }\r\n   // send ack\r\n   bl_send_ack(RES_ACK);\r\n}\r\n```\r\n\r\n## 4 Choose Python as host UART tool\r\nIt is time to pick PC host UART tool.  For easier usage purpose, we choose Python. I had tried to use Ruby serial port gem before Python. However, it is not stable. So Python become the first choice. And very lucky, I found a Python Bootloader UART source code.\r\n* Install Python 2.6/2.7\r\n\r\nGo to web site http://www.python.org to download python and install it under windows.\r\n* Download Python Serial Port Extension\r\n\r\nGet it from web site http://pypi.python.org/pypi/pyserial\r\n* Install Python Serial Port Extension\r\n\r\nExtract the package under Python install directory; execute command below to install the Serial Port Extension.\r\n```python\r\npython setup.py install\r\n```\r\n* Get stm32loader.py and make you own modification.\r\nGet it from web site https://github.com/jsnyder/stm32loader.\r\n\r\n## 5 Build Bootloader code\r\nWe choose Silabs Precision32 UDP MCU Card as our hardware environment.\r\n* Build Bootloader with Precision32 IDE\r\n* Download Bootloader into SIM3U167 internal flash via Serial Wire. \r\n* Power up MCU card and pressing SW2, it enters Bootloader mode, DS3 and DS2 are blinking\r\n\r\n\r\n## 6 Develop User application with Bootloader\r\nUser applications runs on Flash, but start address is not 0x00000000, we have a default value 0x1000. We need to make this modification in user application’s link file.  Just change .text segment load address to 0x1000. And we also want to generate binary file in post build stage of the user application.\r\n\r\n## 7 Bootloader functional test\r\nWe were doing the test on Silabs Precision32 UDP MCU Card.\r\n* Connect USB cable with J10 and PC USB port, PC will found COM4 after power on.\r\n* Copy stm32loader.py to C:\\Python26 (your Python install directory).\r\n* Copy user code binary file to C:\\Python26 directory, for blinky example code, we have a sim3u1xx_Blinky.bin.\r\n* Run Python tool.\r\n```python\r\nC:\\Python26>python sim32loader.py  -wv sim3u1xx_Blinky.bin\r\nsim3u1xx_Blinky.bin\r\n[4, 5, 6, 7]\r\nFile length 3076 bytes\r\nWrite 256 bytes at 0x1000\r\nWrite 256 bytes at 0x1100\r\nWrite 256 bytes at 0x1200\r\nWrite 256 bytes at 0x1300\r\nWrite 256 bytes at 0x1400\r\nWrite 256 bytes at 0x1500\r\nWrite 256 bytes at 0x1600\r\nWrite 256 bytes at 0x1700\r\nWrite 256 bytes at 0x1800\r\nWrite 256 bytes at 0x1900\r\nWrite 256 bytes at 0x1A00\r\nWrite 256 bytes at 0x1B00\r\nWrite 256 bytes at 0x1C00\r\nRead 256 bytes at 0x1000\r\nRead 256 bytes at 0x1100\r\nRead 256 bytes at 0x1200\r\nRead 256 bytes at 0x1300\r\nRead 256 bytes at 0x1400\r\nRead 256 bytes at 0x1500\r\nRead 256 bytes at 0x1600\r\nRead 256 bytes at 0x1700\r\nRead 256 bytes at 0x1800\r\nRead 256 bytes at 0x1900\r\nRead 256 bytes at 0x1A00\r\nRead 256 bytes at 0x1B00\r\nRead 256 bytes at 0x1C00\r\nVerification OK\r\n```\r\n* Run user application\r\n\r\nPress Reset key, we can see DS3 and DS2 are alternate blinking, that means user code Blinky is running.\r\n\r\n## 8 Source code\r\nThe source code can be found in https://github.com/MarkDing/sim3u1xx_Bootloader\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}